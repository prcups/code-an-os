#1.前置 
   .code16 	#将汇编程序bootsect.s 中的汇编指令汇编、链接为16 位的机器指令
BOOTSEG = 0x7c0 
KERNELLEN = 1	# 267B
    ljmp  $BOOTSEG, $go	
go:
    movw  %cs, %ax
    movw  %ax, %ds
#2.将扇区中的文件加载到内存
   
    movb  $0x42, %ah	#0x42功能号
    movb  $0x80, %dl    #磁盘编号0x80
    movw  $parameters, %si
    int   $0x13

#4 5 6为进入保护模式作准备
#4.在保护模式下无法使用实模式中BIOS 创建的中断系统，所以在进入保护模式前，需要关闭中断
    cli            #关闭中断
#5.加载分段信息
    lgdt  gdt_48   #lgdt  加载信息到gdtr寄存器
    movw  $1, %ax  
    lmsw  %ax	  #将32 位寄存器ax 中的值1 赋值给寄存器CR0，即将寄存器CR0 的(最低位)第0 位设置为1，随即开启分段机制。
    ljmp  $8, $0 #进入分段机制以后 寻址方式改变 cs当中保存的是段选择子 这里写作(1 000) 低三位分别指代了TI PRL均为0 第四位开始表示GDT表项索引

#2.将扇区中的文件加载到内存
parameters:
    .word 0x0010   #2字节 默认参数
    .word KERNELLEN #2字节 要读取几个扇区的内容
    .long 0x07e00000#4字节 加载到内存的位置
    .quad 1#8字节 开始读取的扇区号

#3.分段机制 建立全局段描述表 并载入系统
#3.2
gdt_48:
    .word (gdt_end-gdt)-1		#gdt表的边界 减1的原因类比数组大小26 下标从0~25 26-1得到数组的边界
    .long 0x7c00+gdt			#gdt表在内存中的起始地址
#3.1 全局段描述表  预先写入四个段描述符
gdt:
    .quad 0                              #GDT 的第0 项（项号从0 开始）必须为空；8字节
    .word 0x01ff, 0x7e00, 0x9a00, 0x0040 #第一项0x7e00开始的 长度512字节的 可读可执行的代码段
    .word 0x11a0, 0x7e00, 0x9200, 0x004b #第二项0x7e00开始的 长度725409字节的 可读可写的数据段
#0xb8000-0x7e00+1=B0201  当段限长为0xb0201时可以到达b8000 而继承b8000的4000(0xfa0)字节后 段限长为0xb11a1 很庆幸没有超过1M空间，因此G=0,修改段边界为0xb11a0
#另外要在段基基础上，加偏移0xb0200才能到b8000 写显存时要格外注意
    .word 0x01ff, 0x9000, 0x9200, 0x0040 #第三项0x9000开始的 长度512字节的 可读可写的栈段

gdt_end:				#用来配合gdt使用  分别标识开头 结尾 用来确定全局段描述表的长度
    .org  0x1fe				
    .word 0xaa55			#标记启动扇区
